# **Abstract**
A Docker-ized μservice using Spring Boot [Spring Boot](http://projects.spring.io/spring-boot/) 1.5.2 and Hibernate [Hibernate5](https://www.hibernate.org) deployed via an embedded Jetty Container.

## **Introduction**
A starting template if you want to develop a μservice with SpringBoot and Hibernate with an embedded Jetty Container.

Then, we have the following objectives:

  * Development and Deployment should be simple. `java appname.jar` should be enough to run all services at the same time. 
  * Development and Deployment should be simple and deployable to any standalone or embedded container. For the purposes of ACSDAL/MIDSES applications, the application should be deployable to the following containers without any additional configurations:
    * Tomcat 8
    * Red Hat JBoss EAP 6.4+
    * Jetty
    * Glassfish
  * Common code, dependencies and modules should be easily shared as versioned Maven dependencies hosted on a private Nexus repository.
  * Feature code should be separated from core code and considered for sharable code packaging.
  * We should be able to compile, test and run each service separately in development and production. 
  * We should distribute each service separately within a Docker Container.
  * It should be a template ready to use with the following features:
    * Simple and easy to use [Maven 3](https://maven.apache.org/) or [Gradle 3.x](https://gradle.org/) configurations complete with environment specific profiles for Local, Development (i.e. COCO), QA (i.e. MIDSES Development Enclave) and Production (i.e. MIDSES Production Enclave) environments
    * Database Support via [H2](https://www.h2database.com) for local development/integration testing and [MySQL](https://www.mysql.com) or [Oracle](https://www.oracle.com/database/) for the Development, QA and Production environments
    * Dependency Injection with Spring
    * Standardized logging using [SLF4J](http://www.slf4j.org) 1.7.xx complete with serialized rolling logs
    * JPA implementation using Hibernate 5
    * JPA Caching via Spring Cache, Hazelcast, EhCache or Guava
    * A standardized health check endpoint using the `/health` URL path
    * HateOAS based REST endpoints
    * GZip
    * Database change sets maintained by Flyway
    * Testable JPA Unit/Integration Tests using an In-Memory and/or Database implementation with post-execution database cleanup
  * It should explain: 
    * How to share every common code to avoid duplications (model, controller, ...).
    * How to separate feature code from core code.
    * How to build and deploy the application for local, development, and production environments.
    
## **Database**

This template uses HikariCP for the connection pool against a MySQL/MariaDB database. For local development and integration tests, we have configured the application to leverage the H2 in-memory database using the MYSQL dialect.

## **Dependency-Injection**

Using Spring DI to create Singleton and Scope based components that can be injected into other classes.

## **Logging**

The Logback logger is configured for a better output and contains a rolling file
appender. The logs are look like 
`2015-11-10 14:35:40.901  INFO 29475 --- [main] com.dayelostraco.MicroserviceApplication   : Started MicroserviceApplication in 5.302 seconds (JVM running for 5.722)`.

## **JPA**

This template uses Spring Data and Hibernate as the JPA provider. HikariCP is serving as the Connection Pooling provider.

## **Caching**

Implemented Spring's ConcurrentMapCacheManager and Annotation based configuration. See `SampleModelRepository.java` for an example of annotation based cache put/eviction.

## **HateOAS**

Implemented Spring's HateOAS libraries to support links on `@Controller` and `@RestController` endpoints. Refer to `SampleController.java` for an example of adding HateOAS support to a Spring MVC REST endpoint.

For more on HateOAS, please peruse Spring's quick overview of [HateOAS](https://spring.io/understanding/HATEOAS)

## **Auditing**

We're still debating where the responsibility for auditing should reside (application or database). In the meantime, We have included Hibernate Envers and auditing can be implemented to any entity by adding a `@Audited` annotation.

TODO: Spring Data Envers

## **Transformation (DTOs)**

Leverages Spring Data REST Projection to convert entities to specified DTOs via @RepositoryRestResource annotation.

TODO: Might make more sense to implement Orika with an Interface Wrapper

## **Role Based Permissions**

TODO: Add Spring Security 4 or Deadbolt?

## **GZip Compression**

GZip compression and file types are configured in the application.properties.

## **Interactive API Documentation**

API Documentation is automatically generated by Springfox's Spring Swagger2 Plugin on every build. It will automatically scan all specified Controllers, Models and Services and generate Swagger 2 markup. Leverage Springfox Swagger Annotations in your code to further decorate the Swagger markup with descriptions, notes, expected HTTP response codes etc.

To access the auto-generated Swagger Documentation, start your application and access the [Swagger UI](localhost:8080/swagger-ui.html) in your browser.

For example usages of the Springfox Swagger Annotations, see `HeartBeatController.java` or the entity classes located in `acsdal-common-dao` Maven module.

## **Testing**

This can be accomplished via SpringBootTest using the `test` Spring profile.

## **JavaDoc Generation**

If you want to automatically generate JavaDocs HTML as part of the build process, you can use the chainable `release` Maven profile in addition to the environment Maven profile.

**For example:** `mvn -Pdevelopment clean site`

Generated JavaDocs for all modules will be automatically aggregated to the top level target folder under site -> apidocs -> index.html

## **SonarQube Generation**

If you want to automatically generate SonarQube reports as part of the build process, you can use the chainable `release` Maven profile in addition to the environment Maven profile.

**For example:** `mvn -Pdevelopment clean site`

Generated Sonar reports for all modules will be automatically aggregated to the top level target folder under site -> sonar

**NOTE:** You must set up your local .m2 settings to be pointed to your local or remote Sonar server. You will add a sonar profile to the settings.xml located within your .m2 folder with a setting similar to the below:

`        
<profile>  
    <id>sonar</id>  
    <activation>  
         <activeByDefault>false</activeByDefault>  
     </activation>  
     <properties>  
         <!-- Optional URL to server. Default value is http://localhost:9000 -->  
         <sonar.host.url>  
             http://localhost:9000  
         </sonar.host.url>  
     </properties>  
 </profile>  
`

## **Slack Notifications**

Slack notifications are sent to the private #coco channel located on the MIDSES Slack channel. If you do not have access to the #coco channel, please send a request for access to dayel.ostraco@caci.com.

#### **GitHub**

  1. Push Events
  2. Tag Push Events
  3. Issues Events
  4. Merge Request events
  5. Wiki Page events
  6. Notes
  
#### **Jenkins**
  
Coming Soon!

#### **JIRA**
  
Coming Soon!

## **Performance Metrics**

Added New Relic support via Maven plugins and Docker. You will need to update the newrelic.yml file contained in the src/main/resources directory with your application name, license_key and other desired custom configurations.

## **Application Build & Deployment**

Before you begin, be sure to have the following installed on your build machine:

  * Java JDK 1.8 with a minimum version of 1.8.0-30 and maximum version of 1.8.0-60
    * Run the `java -version` command to determine if the correct Java JDK is installed
  * Maven 3 with a minimum version of 3.1.0 and a maximum version of 3.3.9
    * Run the `mvn -version` command to determine if the correct version of Maven 3 is installed

### **Available Build Profiles**

  * **local** - Local Developer Machine
  * **development** - Development Environment
  * **production** - Production Environment

### **Deployment Instructions**

##### **Maven CLI**

  1. If you are not on a Linux based OS, open a Terminal window (if you are on OSX) or CMD (if you are on Windows).
  2. Navigate to the directory that contains the acsdal-wiir-microservice project.
    * **For example:** `cd /Users/testytesterson/Development/springboot-microservice-seed`
  3. Navigate to the springboot-microservice-seed directory.
    * **For example:** `cd /springboot-microservice-seed`
  4. Add the Spring Profile for the environment you want to build to using the Maven -P (Profile) flag.
    * **For example:** `mvn -Pdevelopment clean install`
     
##### **Application Container**

Deploy the generated `springboot-microservice-seed.jar` to Tomcat 8.x, Red Hat JBoss EAP 6.4+ or another SpringBoot supported container.

##### **Docker**

The mvn install/package phase will build a ZIP file that can be utilized for Docker deployments containing the follow:

* Compiled SpringBoot jar
* Dockerfile for the selected Spring Profile
* Additional Agent jars needed for Performance Metrics capture. (e.g. NewRelic, Datadog, Ruxit etc)

###### AWS Elastic Beanstalk

In order to facilitate deployments to AWS ElasticBeanstalk, there is an included .ebextensions folder that configures nginx.

This template is designed to use Docker as the deployed container. In order to facilitate deployments
to AWS ElasticBeanstalk, there is an included .ebextensions folder that configures nginx.

1. From the command line, navigate to the project folder.

2. Run mvn clean package

3. Login into the desired AWS Account and navigate to the Elastic Beanstalk application. Select the applicable Docker based application.

4. Click on the "Upload and Deploy" button. Click "Choose File" option and select the ZIP file created on Step 3 that is located in the /target folder.

5. Select the "Fixed" deployment limit option and enter in 1 as the option. This will deploy the latest version of the application to one instance at a time to maintain the uptime of the app.#   e a s y m o v e - m i c r o s e r v i c e  
 